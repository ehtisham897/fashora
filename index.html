from panda3d.core import Vec3, BitMask32
from panda3d.bullet import BulletWorld, BulletRigidBodyNode, BulletVehicle, BulletBoxShape
from direct.showbase.ShowBase import ShowBase

class AdvancedCarSimulation(ShowBase):
    def __init__(self):
        ShowBase.__init__(self)
        
        # Set up the physics world
        self.world = BulletWorld()
        self.world.setGravity(Vec3(0, 0, -9.81))
        
        # Set up the ground
        self.ground_node = BulletRigidBodyNode('Ground')
        ground_shape = BulletBoxShape(Vec3(50, 50, 1))
        self.ground_node.addShape(ground_shape)
        self.ground_node.setMass(0)  # Static object
        self.ground = self.render.attachNewNode(self.ground_node)
        self.ground.setPos(0, 0, -1)
        self.world.attachRigidBody(self.ground_node)
        
        # Add a visual model for the ground
        ground_visual = self.loader.loadModel("models/environment")
        ground_visual.reparentTo(self.ground)
        ground_visual.setScale(0.25, 0.25, 0.25)
        ground_visual.setPos(-8, 42, 0)
        
        # Set up the car
        car_body_node = BulletRigidBodyNode('CarBody')
        car_body_shape = BulletBoxShape(Vec3(1, 2, 0.5))
        car_body_node.addShape(car_body_shape)
        car_body_node.setMass(800)  # Set mass for the car
        self.car_body = self.render.attachNewNode(car_body_node)
        self.car_body.setPos(0, 0, 1)
        self.world.attachRigidBody(car_body_node)
        
        # Add a visual model for the car
        car_visual = self.loader.loadModel("models/box")
        car_visual.setScale(1, 2, 0.5)
        car_visual.reparentTo(self.car_body)
        
        # Set up the vehicle
        self.vehicle = BulletVehicle(self.world, car_body_node)
        self.vehicle.setCoordinateSystem(BulletVehicle.ZUp)  # Fixed ZUp issue
        self.world.attachVehicle(self.vehicle)
        
        # Add wheels to the vehicle
        wheel_shape = BulletBoxShape(Vec3(0.2, 0.5, 0.5))
        wheel_pos = [(-0.9, 1.5, 0.3), (0.9, 1.5, 0.3), (-0.9, -1.5, 0.3), (0.9, -1.5, 0.3)]
        for pos in wheel_pos:
            self.vehicle.addWheel(self.car_body, Vec3(*pos), Vec3(0, 0, -1), Vec3(0, 1, 0), 0.4, 0.5, True)
        
        # Input keys
        self.keys = {"forward": False, "backward": False, "left": False, "right": False}
        self.accept("arrow_up", self.setKey, ["forward", True])
        self.accept("arrow_up-up", self.setKey, ["forward", False])
        self.accept("arrow_down", self.setKey, ["backward", True])
        self.accept("arrow_down-up", self.setKey, ["backward", False])
        self.accept("arrow_left", self.setKey, ["left", True])
        self.accept("arrow_left-up", self.setKey, ["left", False])
        self.accept("arrow_right", self.setKey, ["right", True])
        self.accept("arrow_right-up", self.setKey, ["right", False])
        
        # Update the simulation
        self.taskMgr.add(self.update, "update")
    
    def setKey(self, key, value):
        self.keys[key] = value
    
    def update(self, task):
        dt = globalClock.getDt()
        
        # Physics update
        self.world.doPhysics(dt, 10, 1.0/180.0)
        
        # Car controls
        if self.keys["forward"]:
            self.vehicle.applyEngineForce(200, 2)  # Apply force to rear wheels
            self.vehicle.applyEngineForce(200, 3)
        elif self.keys["backward"]:
            self.vehicle.applyEngineForce(-200, 2)
            self.vehicle.applyEngineForce(-200, 3)
        else:
            self.vehicle.applyEngineForce(0, 2)
            self.vehicle.applyEngineForce(0, 3)
        
        if self.keys["left"]:
            self.vehicle.setSteeringValue(0.5, 0)  # Front left wheel
            self.vehicle.setSteeringValue(0.5, 1)  # Front right wheel
        elif self.keys["right"]:
            self.vehicle.setSteeringValue(-0.5, 0)
            self.vehicle.setSteeringValue(-0.5, 1)
        else:
            self.vehicle.setSteeringValue(0, 0)
            self.vehicle.setSteeringValue(0, 1)
        
        return task.cont

# Run the simulation
app = AdvancedCarSimulation()
app.run()
